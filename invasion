mport os
import cv2
import tempfile
import numpy as np
import streamlit as st

# Optional: use YOLOv8 via ultralytics if available
try:
    from ultralytics import YOLO
    YOLO_AVAILABLE = True
except Exception:
    YOLO_AVAILABLE = False

st.set_page_config(page_title="occlusionX – POC", layout="wide")

PRIMARY_BLUES = {
    "primary": "#0A4D8C",
    "mid": "#1F6FB2",
    "secondary": "#2D9CDB",
    "accent": "#4FB3FF",
    "rich_black": "#0A0A0A"
}

def draw_header():
    st.markdown(
        f"""
        <div style="display:flex;align-items:center;gap:12px;">
            <div style="width:12px;height:28px;background:{PRIMARY_BLUES['accent']};border-radius:4px;"></div>
            <h2 style="margin:0;">occlusionX &middot; Proof of Concept</h2>
        </div>
        """,
        unsafe_allow_html=True
    )
    st.caption("Upload a short game clip, select an occlusion mode, and render a masked playback.")

def load_model():
    if not YOLO_AVAILABLE:
        return None
    try:
        # person class is in general model yolov8n
        model = YOLO("yolov8n.pt")
        return model
    except Exception as e:
        st.warning(f"YOLO model not available in this environment: {e}")
        return None

def detect_people(model, frame, conf=0.4):
    # returns list of bboxes [x1,y1,x2,y2] and scores
    if model is None:
        # Fallback: no detection, return empty
        return []
    results = model.predict(source=frame, conf=conf, verbose=False)
    bboxes = []
    if len(results) > 0:
        r0 = results[0]
        for box in r0.boxes:
            cls_id = int(box.cls[0].item()) if hasattr(box, "cls") else -1
            if cls_id == 0:  # person class
                xyxy = box.xyxy[0].cpu().numpy().astype(int).tolist()
                bboxes.append(xyxy)
    return bboxes

def apply_occlusion(frame, boxes, keep_n=3, style="dim", dim_alpha=0.65, blur_ksize=31):
    """Occlude all detected players except the top-N by bbox area."""
    if not boxes:
        return frame
    # sort boxes by area desc
    areas = [ (i, (x2-x1)*(y2-y1)) for i,(x1,y1,x2,y2) in enumerate(boxes) ]
    areas.sort(key=lambda t: t[1], reverse=True)
    keep_idx = set([i for i,_ in areas[:max(keep_n,0)]])
    out = frame.copy()

    for i,(x1,y1,x2,y2) in enumerate(boxes):
        x1, y1 = max(0, x1), max(0, y1)
        x2, y2 = min(frame.shape[1]-1, x2), min(frame.shape[0]-1, y2)
        if i in keep_idx:
            # keep visible
            continue
        roi = out[y1:y2, x1:x2]
        if roi.size == 0:
            continue
        if style == "blur":
            k = max(3, blur_ksize | 1)
            blurred = cv2.GaussianBlur(roi, (k, k), 0)
            out[y1:y2, x1:x2] = blurred
        else:
            # dim overlay
            overlay = roi.copy()
            overlay[:] = (0,0,0)
            cv2.addWeighted(overlay, dim_alpha, roi, 1-dim_alpha, 0, roi)
            out[y1:y2, x1:x2] = roi
    return out

def write_video(frames, fps, out_path):
    if not frames:
        return None
    h, w = frames[0].shape[:2]
    writer = cv2.VideoWriter(out_path, cv2.VideoWriter_fourcc(*"mp4v"), fps, (w,h))
    for f in frames:
        writer.write(f)
    writer.release()
    return out_path

def main():
    draw_header()

    with st.sidebar:
        st.subheader("Controls")
        sport = st.selectbox("Sport", ["Soccer", "Basketball", "Hockey"], index=0)
        occlusion_mode = st.selectbox("Occlusion Style", ["dim", "blur"], index=0)
        keep_n = st.slider("Keep visible players (N)", 0, 10, 3, 1)
        conf_thr = st.slider("Detection confidence", 0.25, 0.8, 0.4, 0.05)
        frame_skip = st.slider("Process every Nth frame", 1, 5, 2, 1, help="Higher = faster processing, choppier output")
        preview_only = st.checkbox("Preview a single frame first", value=True)
        st.markdown("---")
        st.caption("Tip: Use **short clips** (under 20s) for faster results.")

    col1, col2 = st.columns([1,1])
    with col1:
        video_file = st.file_uploader("Upload MP4 video", type=["mp4", "mov", "m4v"])

    if video_file is None:
        st.info("Upload a short clip to get started.")
        return

    # Save upload to temp file
    tdir = tempfile.mkdtemp()
    src_path = os.path.join(tdir, "input.mp4")
    with open(src_path, "wb") as f:
        f.write(video_file.read())

    # Load video
    cap = cv2.VideoCapture(src_path)
    if not cap.isOpened():
        st.error("Could not read the video. Try a different file.")
        return

    fps = cap.get(cv2.CAP_PROP_FPS) or 25
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    st.caption(f"Detected FPS: {fps:.1f} • Frames: {total_frames}")

    model = load_model()

    # Preview first frame processing
    ret, frame = cap.read()
    if not ret:
        st.error("Could not read the first frame.")
        return

    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    boxes = detect_people(model, frame_rgb, conf=conf_thr)
    preview = apply_occlusion(frame_rgb, boxes, keep_n=keep_n, style=occlusion_mode)

    with col1:
        st.write("**Original (first frame)**")
        st.image(frame_rgb, use_container_width=True)
    with col2:
        st.write(f"**Occlusion Preview** — keep {keep_n} visible")
        st.image(preview, use_container_width=True)

    if preview_only:
        st.warning("Preview-only mode is ON. Uncheck to render the full occluded video.")
        return

    # Process full video
    st.markdown("### Rendering Occluded Video")
    frames_out = []
    cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
    i = 0
    progress = st.progress(0)
    total_to_process = max(1, total_frames // frame_skip)

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        if i % frame_skip != 0:
            i += 1
            continue
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        boxes = detect_people(model, rgb, conf=conf_thr)
        occluded = apply_occlusion(rgb, boxes, keep_n=keep_n, style=occlusion_mode)
        frames_out.append(cv2.cvtColor(occluded, cv2.COLOR_RGB2BGR))
        i += 1
        progress.progress(min(1.0, len(frames_out)/total_to_process))

    cap.release()

    # Write to mp4 (same fps / frame_skip)
    out_mp4 = os.path.join(tdir, "occluded_output.mp4")
    eff_fps = max(1, int(fps // frame_skip))
    write_video(frames_out, eff_fps, out_mp4)

    st.success("Done!")
    st.video(out_mp4)
    with open(out_mp4, "rb") as f:
        st.download_button("Download occluded video (MP4)", f, file_name="occlusionx_occluded.mp4", mime="video/mp4")

    st.markdown("---")
    st.caption("MVP limitations: no player ID tracking yet; occlusion is based on bbox area for a quick proof-of-concept.")

if __name__ == "__main__":
    main()
